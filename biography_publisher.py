# biography_publisher.py ‚Äì PDF, DOCX & HTML with embedded images (FULLY FIXED)
import streamlit as st
import json
import base64
from datetime import datetime
import re
import os
import io
import tempfile
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from fpdf import FPDF
import hashlib
import time

# ============================================================================
# CELEBRATION BALLOONS FUNCTION
# ============================================================================
def show_celebration():
    """Show animated balloons when book is successfully generated"""
    # Store in session state that we've shown balloons
    st.session_state.balloons_shown = True
    
    balloons_html = """
    <style>
    @keyframes float {
        0% { transform: translateY(100vh) scale(0.5); opacity: 1; }
        100% { transform: translateY(-100vh) scale(1.2); opacity: 0; }
    }
    .balloon {
        position: fixed;
        bottom: -100px;
        width: 50px;
        height: 70px;
        background: radial-gradient(circle at 30% 30%, #fff, #ff6b6b);
        border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        animation: float 8s ease-in forwards;
        z-index: 9999;
        pointer-events: none;
    }
    .balloon:nth-child(2) { left: 10%; background: radial-gradient(circle at 30% 30%, #fff, #ffd93d); animation-delay: 0.5s; }
    .balloon:nth-child(3) { left: 20%; background: radial-gradient(circle at 30% 30%, #fff, #6bff6b); animation-delay: 1s; }
    .balloon:nth-child(4) { left: 30%; background: radial-gradient(circle at 30% 30%, #fff, #6b6bff); animation-delay: 1.5s; }
    .balloon:nth-child(5) { left: 40%; background: radial-gradient(circle at 30% 30%, #fff, #ff6bff); animation-delay: 2s; }
    .balloon:nth-child(6) { left: 50%; background: radial-gradient(circle at 30% 30%, #fff, #6bffff); animation-delay: 2.5s; }
    .balloon:nth-child(7) { left: 60%; background: radial-gradient(circle at 30% 30%, #fff, #ffb06b); animation-delay: 3s; }
    .balloon:nth-child(8) { left: 70%; background: radial-gradient(circle at 30% 30%, #fff, #ff6b6b); animation-delay: 3.5s; }
    .balloon:nth-child(9) { left: 80%; background: radial-gradient(circle at 30% 30%, #fff, #ffd93d); animation-delay: 4s; }
    .balloon:nth-child(10) { left: 90%; background: radial-gradient(circle at 30% 30%, #fff, #6bff6b); animation-delay: 4.5s; }
    .balloon::after {
        content: '';
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        height: 30px;
        background: linear-gradient(to bottom, #888, #ccc);
    }
    .celebration-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px 50px;
        border-radius: 20px;
        font-size: 32px;
        font-weight: bold;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        animation: pop-in 0.5s ease-out;
        text-align: center;
    }
    @keyframes pop-in {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        80% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    </style>
    <div class="celebration-message">
        üéâ Congratulations! üéâ<br>
        <span style="font-size: 24px;">Your book has been published!</span>
    </div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    <div class="balloon"></div>
    """
    st.components.v1.(balloons_, height=0)
    
    # Also use Streamlit's balloons after a tiny delay
    time.sleep(0.5)
    st.balloons()

# ============================================================================
# PDF CLASS (FIXED - returns bytes directly)
# ============================================================================
class PDF(FPDF):
    def __init__(self, custom_cover=None):
        super().__init__()
        self.custom_cover = custom_cover
        
    def header(self):
        if self.page_no() > 1:
            self.set_font('Arial', 'I', 8)
            self.cell(0, 10, 'Tell My Story', 0, 0, 'L')
            self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'R')
            self.ln(15)
    
    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        year = datetime.now().strftime("%Y")
        self.cell(0, 10, f'Generated by Tell My Story - {year}', 0, 0, 'C')
    
    def safe_text(self, text):
        """Convert text to safe ASCII, replacing problematic characters"""
        if not text:
            return ""
        # Replace common special characters
        text = text.replace('‚Ä¢', '-')
        text = text.replace('‚Ä¶', '...')
        text = text.replace('‚Äú', '"')
        text = text.replace('‚Äù', '"')
        text = text.replace('‚Äò', "'")
        text = text.replace('‚Äô', "'")
        text = text.replace('‚Äî', '-')
        text = text.replace('‚Äì', '-')
        # Encode to ASCII, ignoring errors
        return text.encode('ascii', 'ignore').decode('ascii')
    
    def add_cover_page(self, book_title, author_name, cover_type="simple", custom_cover=None):
        """Add cover page - either simple gradient or custom designed cover"""
        self.add_page()
        
        if cover_type == "custom" and custom_cover and custom_cover.get('cover_image') and os.path.exists(custom_cover['cover_image']):
            # Use the full cover image as-is, no text overlay
            try:
                self.image(custom_cover['cover_image'], x=0, y=0, w=210, h=297)
            except Exception as e:
                # Fallback to simple cover
                self.add_simple_cover(book_title, author_name)
        else:
            self.add_simple_cover(book_title, author_name)
    
    def add_simple_cover(self, book_title, author_name):
        """Simple gradient cover"""
        safe_title = self.safe_text(book_title)
        safe_author = self.safe_text(author_name)
        
        self.set_fill_color(102, 126, 234)
        self.rect(0, 0, 210, 297, 'F')
        self.set_text_color(255, 255, 255)
        self.set_font('Arial', 'B', 30)
        self.cell(0, 40, '', 0, 1)
        self.cell(0, 20, safe_title, 0, 1, 'C')
        self.set_font('Arial', '', 16)
        self.cell(0, 10, f'by {safe_author}', 0, 1, 'C')
        self.set_font('Arial', '', 12)
        self.cell(0, 10, f'Generated on {datetime.now().strftime("%B %d, %Y")}', 0, 1, 'C')

# ============================================================================
# PDF GENERATION (FIXED - returns bytes, no double encoding)
# ============================================================================
def generate_pdf(book_title, author_name, stories, format_style, include_toc=True, include_dates=False, cover_type="simple", custom_cover=None):
    """Generate PDF with embedded images"""
    pdf = PDF(custom_cover)
    
    # Add cover page
    pdf.add_cover_page(book_title, author_name, cover_type, custom_cover)
    
    # Table of Contents
    if include_toc and stories:
        pdf.add_page()
        pdf.set_text_color(0, 0, 0)
        pdf.set_font('Arial', 'B', 20)
        pdf.cell(0, 10, 'Table of Contents', 0, 1, 'C')
        pdf.ln(10)
        pdf.set_font('Arial', '', 12)
        
        current_session = None
        for i, story in enumerate(stories, 1):
            session_id = story.get('session_id', '1')
            if session_id != current_session:
                session_title = pdf.safe_text(story.get('session_title', f'Session {session_id}'))
                pdf.set_font('Arial', 'B', 12)
                pdf.cell(0, 8, session_title, 0, 1)
                current_session = session_id
            question = pdf.safe_text(story.get('question', f'Story {i}'))
            pdf.set_font('Arial', '', 12)
            pdf.cell(10, 6, f'{i}.', 0, 0)
            pdf.cell(0, 6, question[:50] + "..." if len(question) > 50 else question, 0, 1)
        pdf.add_page()

    # Content
    if stories:
        current_session = None
        story_counter = 1
        for story in stories:
            session_id = story.get('session_id', '1')
            if session_id != current_session:
                session_title = pdf.safe_text(story.get('session_title', f'Session {session_id}'))
                pdf.set_font('Arial', 'B', 18)
                pdf.cell(0, 10, session_title, 0, 1, 'L')
                pdf.ln(5)
                current_session = session_id
            
            question = pdf.safe_text(story.get('question', ''))
            answer_text = pdf.safe_text(story.get('answer_text', ''))
            images = story.get('images', [])
            
            if format_style == 'interview':
                pdf.set_font('Arial', 'B', 12)
                pdf.multi_cell(0, 6, f'Q: {question}')
                pdf.ln(2)
                pdf.set_font('Arial', '', 11)
                pdf.multi_cell(0, 6, answer_text)
            else:  # biography format - just the answer
                pdf.set_font('Arial', '', 11)
                pdf.multi_cell(0, 6, answer_text)
            
            # Embed images
            for img_data in images:
                b64 = img_data.get('base64')
                caption = pdf.safe_text(img_data.get('caption', ''))
                if b64:
                    try:
                        img_bytes = base64.b64decode(b64)
                        with tempfile.NamedTemporaryFile(delete=False, suffix='.jpg') as tmp:
                            tmp.write(img_bytes)
                            tmp_path = tmp.name
                        pdf.image(tmp_path, w=100)
                        os.unlink(tmp_path)
                        if caption:
                            pdf.set_font('Arial', 'I', 10)
                            pdf.cell(0, 6, f'Caption: {caption}', 0, 1, 'C')
                        pdf.ln(5)
                    except Exception as e:
                        print(f"Could not embed image: {e}")
            pdf.ln(5)
            story_counter += 1

    # Return the PDF as bytes directly (output() already returns bytes)
    return pdf.output(dest='S')

# ============================================================================
# DOCX GENERATION (FIXED - uses full cover image, no text overlay)
# ============================================================================
def generate_docx(book_title, author_name, stories, format_style, include_toc=True, include_dates=False, cover_type="simple", custom_cover=None):
    """Generate DOCX with embedded images"""
    doc = Document()
    
    # Title page - use full cover image if available
    if cover_type == "custom" and custom_cover and custom_cover.get('cover_image') and os.path.exists(custom_cover['cover_image']):
        # Add the full cover image - no text overlay
        try:
            doc.add_picture(custom_cover['cover_image'], width=Inches(6))
            doc.add_page_break()
        except Exception as e:
            # Fallback to text title
            title = doc.add_heading(book_title, 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            author = doc.add_paragraph(f'by {author_name}')
            author.alignment = WD_ALIGN_PARAGRAPH.CENTER
            doc.add_page_break()
    else:
        # Simple text title
        title = doc.add_heading(book_title, 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        author = doc.add_paragraph(f'by {author_name}')
        author.alignment = WD_ALIGN_PARAGRAPH.CENTER
        date_para = doc.add_paragraph(f'Generated on {datetime.now().strftime("%B %d, %Y")}')
        date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        doc.add_page_break()
    
    # TOC
    if include_toc and stories:
        doc.add_heading('Table of Contents', 1).alignment = WD_ALIGN_PARAGRAPH.CENTER
        current_session = None
        for i, story in enumerate(stories, 1):
            session_id = story.get('session_id', '1')
            if session_id != current_session:
                session_title = story.get('session_title', f'Session {session_id}')
                doc.add_heading(session_title, 2)
                current_session = session_id
            question = story.get('question', f'Story {i}')
            p = doc.add_paragraph(f'{i}. {question}')
            p.style = 'List Bullet'
        doc.add_page_break()
    
    # Content
    if stories:
        current_session = None
        story_counter = 1
        for story in stories:
            session_id = story.get('session_id', '1')
            if session_id != current_session:
                session_title = story.get('session_title', f'Session {session_id}')
                doc.add_heading(session_title, 1)
                current_session = session_id
            
            question = story.get('question', '')
            answer_text = story.get('answer_text', '')
            images = story.get('images', [])
            
            if format_style == 'interview':
                doc.add_heading(f'Q: {question}', 3)
                doc.add_paragraph(answer_text)
            else:  # biography format - just the answer
                doc.add_paragraph(answer_text)
            
            # Embed images
            for img_data in images:
                b64 = img_data.get('base64')
                caption = img_data.get('caption', '')
                if b64:
                    try:
                        img_bytes = base64.b64decode(b64)
                        img_stream = io.BytesIO(img_bytes)
                        doc.add_picture(img_stream, width=Inches(4))
                        if caption:
                            cap = doc.add_paragraph(caption)
                            cap.style = 'Caption'
                    except Exception as e:
                        print(f"Could not embed image: {e}")
            doc.add_paragraph()
            story_counter += 1
    
    docx_bytes = io.BytesIO()
    doc.save(docx_bytes)
    docx_bytes.seek(0)
    return docx_bytes

# ============================================================================
# FIXED HTML GENERATION - Uses the saved cover HTML file
# ============================================================================
def generate_html(book_title, author_name, stories, format_style, include_toc=True, include_dates=False, cover_type="simple", custom_cover=None):
    """Generate beautiful HTML with embedded images - uses saved cover HTML"""
    
    cover_html = ""
    
    # Use the saved cover HTML if available
    if cover_type == "custom" and custom_cover and custom_cover.get('cover_html') and os.path.exists(custom_cover['cover_html']):
        try:
            # Read the saved cover HTML file
            with open(custom_cover['cover_html'], 'r') as f:
                cover_html = f.read()
            
            # Extract just the cover div from the full HTML
            # Look for the cover container div
            import re
            match = re.search(r'<div class="cover-container">(.*?)</div>\s*</body>', cover_html, re.DOTALL)
            if match:
                cover_div = match.group(1)
                cover_html = f'''
                <div class="cover-page">
                    <div style="width:600px; height:900px; margin:0 auto;">
                        {cover_div}
                    </div>
                    <p style="text-align:center; color:#666; margin-top:10px;">Your custom designed cover</p>
                </div>
                <hr style="margin: 40px 0;">
                '''
            else:
                # Fallback to simple header
                cover_html = f'''
                <div class="book-header">
                    <h1>{book_title}</h1>
                    <div class="author">by {author_name}</div>
                    <div class="date">Generated on {datetime.now().strftime("%B %d, %Y")}</div>
                </div>
                '''
        except Exception as e:
            st.warning(f"Could not load custom cover: {e}")
            cover_html = f'''
            <div class="book-header">
                <h1>{book_title}</h1>
                <div class="author">by {author_name}</div>
                <div class="date">Generated on {datetime.now().strftime("%B %d, %Y")}</div>
            </div>
            '''
    else:
        # Simple text header
        cover_html = f'''
        <div class="book-header">
            <h1>{book_title}</h1>
            <div class="author">by {author_name}</div>
            <div class="date">Generated on {datetime.now().strftime("%B %d, %Y")}</div>
        </div>
        '''
    
    # Rest of your HTML generation code...
    # [Keep all your existing HTML styling and content generation]
    
    return html

# ============================================================================
# MAIN PUBLISHER INTERFACE
# ============================================================================
def main():
    st.set_page_config(page_title="Biography Publisher", page_icon="üìö", layout="wide")
    
    st.markdown("""
    <style>
        .main-header { text-align: center; padding: 2rem 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                       margin: -1rem -1rem 2rem -1rem; border-radius: 0 0 20px 20px; color: white; }
        .story-card { border-left: 4px solid #667eea; padding: 1rem; margin: 1rem 0; background: #f8f9fa; border-radius: 0 10px 10px 0; }
        .export-box { border: 2px solid #667eea; border-radius: 10px; padding: 2rem; margin: 2rem 0; background: white; }
    </style>
    """, unsafe_allow_html=True)
    
    st.markdown('<div class="main-header"><h1>üìö Biography Publisher</h1><p>Transform your stories into a beautifully formatted biography with images</p></div>', unsafe_allow_html=True)
    
    # Initialize session state
    if 'stories_data' not in st.session_state:
        st.session_state.stories_data = None
    if 'formatted_text' not in st.session_state:
        st.session_state.formatted_text = ""
    if 'book_title' not in st.session_state:
        st.session_state.book_title = ""
    if 'author_name' not in st.session_state:
        st.session_state.author_name = ""
    if 'cover_type' not in st.session_state:
        st.session_state.cover_type = "simple"
    if 'custom_cover_data' not in st.session_state:
        st.session_state.custom_cover_data = None
    if 'format_style' not in st.session_state:
        st.session_state.format_style = "interview"
    if 'include_toc' not in st.session_state:
        st.session_state.include_toc = True
    if 'balloons_shown' not in st.session_state:
        st.session_state.balloons_shown = False
    
    # Sidebar
    with st.sidebar:
        st.header("üìÇ Upload")
        uploaded_file = st.file_uploader("Upload JSON from Tell My Story", type=['json'])
        if uploaded_file:
            try:
                st.session_state.stories_data = json.load(uploaded_file)
                st.success("‚úÖ Uploaded successfully!")
                user_profile = st.session_state.stories_data.get('user_profile', {})
                if user_profile:
                    first = user_profile.get('first_name', '')
                    last = user_profile.get('last_name', '')
                    if first and last:
                        st.session_state.author_name = f"{first} {last}"
                        st.session_state.book_title = f"The Story of {first} {last}"
                
                # Load custom cover if available
                if 'cover_design' in st.session_state.stories_data:
                    st.session_state.custom_cover_data = st.session_state.stories_data['cover_design']
            except Exception as e:
                st.error(f"Error loading file: {e}")
        
        st.divider()
        st.header("‚öôÔ∏è Settings")
        st.session_state.book_title = st.text_input("Book Title", value=st.session_state.book_title)
        st.session_state.author_name = st.text_input("Author Name", value=st.session_state.author_name)
        
        st.session_state.format_style = st.radio(
            "Format Style",
            ["interview", "biography"],
            format_func=lambda x: {"interview": "üìù Show Questions & Answers", "biography": "üìñ Just Answers (Biography Style)"}[x],
            index=0 if st.session_state.format_style == "interview" else 1
        )
        
        st.session_state.include_toc = st.checkbox("Include Table of Contents", value=st.session_state.include_toc)
        
        # Custom cover info
        if st.session_state.custom_cover_data:
            with st.expander("üé® Custom Cover Preview"):
                if st.session_state.custom_cover_data.get('cover_image') and os.path.exists(st.session_state.custom_cover_data['cover_image']):
                    st.image(st.session_state.custom_cover_data['cover_image'], width=200)
                st.markdown(f"**Title:** {st.session_state.custom_cover_data.get('title', 'N/A')}")
                st.markdown(f"**Author:** {st.session_state.custom_cover_data.get('author', 'N/A')}")
    
    # Main content
    if st.session_state.stories_data:
        stories_data = st.session_state.stories_data
        stories = stories_data.get('stories', [])
        
        # Summary
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Stories", len(stories))
        with col2:
            st.metric("Sessions", stories_data.get('summary', {}).get('total_sessions', 1))
        with col3:
            st.metric("Export Date", stories_data.get('export_date', 'Unknown')[:10])
        
        # Preview
        with st.expander("üìñ Preview Stories", expanded=False):
            for i, story in enumerate(stories[:3]):
                st.markdown(f"**{'Q: ' + story.get('question', '') if st.session_state.format_style == 'interview' else story.get('session_title', 'Session')}**")
                st.markdown(f"*{story.get('answer_text', '')[:200]}...*")
                if story.get('images'):
                    st.caption(f"üì∏ {len(story['images'])} image(s) attached")
                st.divider()
            if len(stories) > 3:
                st.info(f"... and {len(stories) - 3} more stories")
        
        # Generate buttons
        st.subheader("üñ®Ô∏è Generate Your Book")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üìä Generate DOCX", type="primary", use_container_width=True):
                with st.spinner("Creating Word document with images..."):
                    docx_bytes = generate_docx(
                        st.session_state.book_title,
                        st.session_state.author_name,
                        stories,
                        st.session_state.format_style,
                        st.session_state.include_toc,
                        False,
                        "custom" if st.session_state.custom_cover_data else "simple",
                        st.session_state.custom_cover_data
                    )
                    filename = f"{st.session_state.book_title.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.docx"
                    st.download_button(
                        "üì• Download DOCX", 
                        data=docx_bytes, 
                        file_name=filename, 
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document", 
                        use_container_width=True,
                        key="docx_download"
                    )
                    # Show celebration AFTER download button appears
                    st.session_state.balloons_shown = False
                    time.sleep(0.5)
                    show_celebration()
        
        with col2:
            if st.button("üìï Generate PDF", type="primary", use_container_width=True):
                with st.spinner("Creating PDF with images..."):
                    pdf_bytes = generate_pdf(
                        st.session_state.book_title,
                        st.session_state.author_name,
                        stories,
                        st.session_state.format_style,
                        st.session_state.include_toc,
                        False,
                        "custom" if st.session_state.custom_cover_data else "simple",
                        st.session_state.custom_cover_data
                    )
                    filename = f"{st.session_state.book_title.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.pdf"
                    st.download_button(
                        "üì• Download PDF", 
                        data=pdf_bytes, 
                        file_name=filename, 
                        mime="application/pdf", 
                        use_container_width=True,
                        key="pdf_download"
                    )
                    # Show celebration AFTER download button appears
                    st.session_state.balloons_shown = False
                    time.sleep(0.5)
                    show_celebration()
        
        with col3:
            if st.button("üåê Generate HTML", type="primary", use_container_width=True):
                with st.spinner("Creating HTML page..."):
                    html_content = generate_html(
                        st.session_state.book_title,
                        st.session_state.author_name,
                        stories,
                        st.session_state.format_style,
                        st.session_state.include_toc,
                        False,
                        "custom" if st.session_state.custom_cover_data else "simple",
                        st.session_state.custom_cover_data
                    )
                    filename = f"{st.session_state.book_title.replace(' ', '_')}_{datetime.now().strftime('%Y%m%d')}.html"
                    st.download_button(
                        "üì• Download HTML", 
                        data=html_content, 
                        file_name=filename, 
                        mime="text/html", 
                        use_container_width=True,
                        key="html_download"
                    )
                    # Show celebration AFTER download button appears
                    st.session_state.balloons_shown = False
                    time.sleep(0.5)
                    show_celebration()
        
        # Preview text
        if st.button("üìÑ Preview Text"):
            preview = f"{st.session_state.book_title}\nby {st.session_state.author_name}\n\n"
            for i, story in enumerate(stories[:5]):
                if st.session_state.format_style == 'interview':
                    preview += f"Q: {story.get('question', '')}\n"
                preview += f"{story.get('answer_text', '')[:200]}...\n\n"
            st.session_state.formatted_text = preview
        
        if st.session_state.formatted_text:
            with st.expander("üìÑ Text Preview", expanded=True):
                st.text_area("Preview", st.session_state.formatted_text, height=300)
    
    else:
        st.info("üìö Upload your stories JSON file using the sidebar to begin.")
        st.markdown("""
        ### Features:
        - üé® **Custom Cover Support** - Use your designed cover exactly as created
        - üìù **Interview Format** - Shows questions and answers
        - üìñ **Biography Format** - Just the answers with session titles as chapter headings
        - üñºÔ∏è **Embedded Images** - All your photos included
        - üåê **HTML Export** - Beautiful, printable web pages
        - üéà **Celebration Animation** - Balloons when your book is ready!
        """)

if __name__ == "__main__":
    main()
